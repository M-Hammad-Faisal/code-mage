# 10 Python Mistakes You're Probably Making Without Realizing It

*Are you guilty of mistake #5? Let's find out! üîç*

Even seasoned Python developers fall into these traps. I've been there, you've been there, and that's perfectly normal! But once you know these mistakes, you'll code like a true Python wizard. Let's dive into the most common pitfalls and how to avoid them.

## 1. Using Mutable Default Arguments üö®

**The Mistake:**
```python
def add_item(item, my_list=[]):
    my_list.append(item)
    return my_list

# This looks innocent, but...
print(add_item("apple"))     # ['apple']
print(add_item("banana"))    # ['apple', 'banana'] - Wait, what?!
print(add_item("cherry"))    # ['apple', 'banana', 'cherry'] - Oh no!
```

**Why It's Wrong:**
The default list is created only once when the function is defined, not each time it's called. This means all function calls share the same list object!

**The Fix:**
```python
def add_item(item, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(item)
    return my_list

# Now it works as expected!
print(add_item("apple"))     # ['apple']
print(add_item("banana"))    # ['banana']
print(add_item("cherry"))    # ['cherry']
```

**Pro Tip:** Use `None` as the default and create the mutable object inside the function.

## 2. Late Binding Closures in Loops üîÑ

**The Mistake:**
```python
functions = []
for i in range(5):
    functions.append(lambda: i)

# What do you think this prints?
for func in functions:
    print(func())  # 4, 4, 4, 4, 4 - All the same!
```

**Why It's Wrong:**
The lambda functions capture the variable `i` by reference, not by value. When the loop ends, `i` equals 4, so all lambdas return 4.

**The Fix:**
```python
# Method 1: Default argument capture
functions = []
for i in range(5):
    functions.append(lambda x=i: x)

# Method 2: Using functools.partial
from functools import partial

functions = []
for i in range(5):
    functions.append(partial(lambda x: x, i))

# Method 3: List comprehension (cleanest)
functions = [lambda x=i: x for i in range(5)]

# Now it works!
for func in functions:
    print(func())  # 0, 1, 2, 3, 4
```

## 3. Modifying a List While Iterating Over It üå™Ô∏è

**The Mistake:**
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Remove even numbers
for num in numbers:
    if num % 2 == 0:
        numbers.remove(num)

print(numbers)  # [1, 3, 5, 7, 9] - Wait, where's 6 and 10?
```

**Why It's Wrong:**
When you remove an item, all subsequent items shift left, causing the iterator to skip elements.

**The Fix:**
```python
# Method 1: Iterate backwards
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for i in range(len(numbers) - 1, -1, -1):
    if numbers[i] % 2 == 0:
        numbers.pop(i)

# Method 2: List comprehension (preferred)
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbers = [num for num in numbers if num % 2 != 0]

# Method 3: Filter function
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbers = list(filter(lambda x: x % 2 != 0, numbers))

print(numbers)  # [1, 3, 5, 7, 9] - Perfect!
```

## 4. Using `==` Instead of `is` for Singleton Comparisons üéØ

**The Mistake:**
```python
# Checking for None
if value == None:
    print("Value is None")

# Checking for boolean values
if flag == True:
    print("Flag is true")
```

**Why It's Wrong:**
- `==` checks for equality (can be overridden)
- `is` checks for identity (same object in memory)
- For singletons like `None`, `True`, `False`, use `is`

**The Fix:**
```python
# Correct way
if value is None:
    print("Value is None")

if flag is True:
    print("Flag is true")

# Even better for booleans
if flag:
    print("Flag is true")

# Demonstrating the difference
class Sneaky:
    def __eq__(self, other):
        return True

sneaky = Sneaky()
print(sneaky == None)  # True (misleading!)
print(sneaky is None)  # False (correct!)
```

## 5. Not Using List Comprehensions When You Should üìù

**The Mistake:**
```python
# Creating a list the long way
squares = []
for i in range(10):
    squares.append(i ** 2)

# Filtering the long way
even_squares = []
for square in squares:
    if square % 2 == 0:
        even_squares.append(square)
```

**The Fix:**
```python
# Pythonic and faster
squares = [i ** 2 for i in range(10)]

# Filtering with comprehension
even_squares = [square for square in squares if square % 2 == 0]

# Or combine them
even_squares = [i ** 2 for i in range(10) if (i ** 2) % 2 == 0]

# Dictionary comprehension
square_dict = {i: i ** 2 for i in range(10)}

# Set comprehension
unique_remainders = {i % 3 for i in range(20)}
```

**Performance Comparison:**
```python
import timeit

# Traditional loop
def traditional_way():
    result = []
    for i in range(1000):
        result.append(i ** 2)
    return result

# List comprehension
def comprehension_way():
    return [i ** 2 for i in range(1000)]

# List comprehension is typically 2-3x faster!
```

## 6. Ignoring the `else` Clause in Loops üîÑ

**The Mistake:**
```python
# Not knowing about loop's else clause
def find_item(items, target):
    found = False
    for item in items:
        if item == target:
            found = True
            break
    
    if not found:
        print(f"{target} not found")
```

**The Fix:**
```python
# Using the else clause elegantly
def find_item(items, target):
    for item in items:
        if item == target:
            print(f"Found {target}!")
            break
    else:
        # This runs only if the loop completed without breaking
        print(f"{target} not found")

# Works with while loops too!
def find_first_even(numbers):
    i = 0
    while i < len(numbers):
        if numbers[i] % 2 == 0:
            print(f"First even number: {numbers[i]}")
            break
        i += 1
    else:
        print("No even numbers found")
```

## 7. Using `+` for String Concatenation in Loops üêå

**The Mistake:**
```python
# Slow string building
result = ""
for i in range(1000):
    result += f"Item {i}, "

# This creates a new string object each time!
```

**Why It's Wrong:**
Strings are immutable in Python. Each `+=` operation creates a new string object, making this O(n¬≤) complexity.

**The Fix:**
```python
# Method 1: Join (fastest for many strings)
items = [f"Item {i}" for i in range(1000)]
result = ", ".join(items)

# Method 2: f-strings for simple cases
name = "Alice"
age = 30
result = f"Hello, {name}! You are {age} years old."

# Method 3: StringIO for complex building
from io import StringIO

buffer = StringIO()
for i in range(1000):
    buffer.write(f"Item {i}, ")
result = buffer.getvalue()

# Performance comparison
import timeit

def slow_way():
    result = ""
    for i in range(1000):
        result += f"Item {i}, "
    return result

def fast_way():
    return ", ".join(f"Item {i}" for i in range(1000))

# fast_way() is typically 10-100x faster!
```

## 8. Not Using `enumerate()` When You Need Both Index and Value üìä

**The Mistake:**
```python
items = ['apple', 'banana', 'cherry', 'date']

# The clunky way
for i in range(len(items)):
    print(f"{i}: {items[i]}")

# Or this way
i = 0
for item in items:
    print(f"{i}: {item}")
    i += 1
```

**The Fix:**
```python
# Clean and Pythonic
items = ['apple', 'banana', 'cherry', 'date']

for i, item in enumerate(items):
    print(f"{i}: {item}")

# You can even start from a different number
for i, item in enumerate(items, start=1):
    print(f"{i}: {item}")

# Real-world example: Finding indices of matching items
def find_all_indices(items, target):
    return [i for i, item in enumerate(items) if item == target]

numbers = [1, 3, 7, 3, 9, 3, 2]
indices = find_all_indices(numbers, 3)
print(indices)  # [1, 3, 5]
```

## 9. Using Bare `except` Clauses üö´

**The Mistake:**
```python
try:
    risky_operation()
except:
    print("Something went wrong")
    # This catches EVERYTHING, even KeyboardInterrupt!
```

**Why It's Wrong:**
Bare `except` catches all exceptions, including system exits, keyboard interrupts, and other exceptions you probably don't want to handle.

**The Fix:**
```python
# Be specific about what you're catching
try:
    result = int(user_input)
except ValueError:
    print("Please enter a valid number")
except TypeError:
    print("Input must be a string")

# If you must catch multiple exceptions
try:
    risky_operation()
except (ValueError, TypeError, KeyError) as e:
    print(f"Expected error occurred: {e}")

# For unexpected errors, catch Exception (not BaseException)
try:
    risky_operation()
except Exception as e:
    print(f"Unexpected error: {e}")
    # Log the error, don't just ignore it!

# Even better: use specific exception handling
import requests

try:
    response = requests.get("https://api.example.com/data")
    response.raise_for_status()
    data = response.json()
except requests.exceptions.ConnectionError:
    print("Network connection failed")
except requests.exceptions.Timeout:
    print("Request timed out")
except requests.exceptions.HTTPError as e:
    print(f"HTTP error occurred: {e}")
except ValueError:
    print("Invalid JSON response")
```

## 10. Not Using Context Managers for Resource Management üóÇÔ∏è

**The Mistake:**
```python
# Risky file handling
file = open('data.txt', 'r')
data = file.read()
file.close()  # What if an exception occurs before this?

# Risky database connection
import sqlite3
conn = sqlite3.connect('database.db')
cursor = conn.cursor()
cursor.execute("SELECT * FROM users")
results = cursor.fetchall()
conn.close()  # Again, what if something goes wrong?
```

**Why It's Wrong:**
If an exception occurs, the file or connection might not be properly closed, leading to resource leaks.

**The Fix:**
```python
# Safe file handling
with open('data.txt', 'r') as file:
    data = file.read()
# File is automatically closed, even if an exception occurs

# Safe database handling
import sqlite3
with sqlite3.connect('database.db') as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")
    results = cursor.fetchall()
# Connection is automatically closed

# Creating your own context manager
class Timer:
    def __enter__(self):
        import time
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        print(f"Execution took {self.end - self.start:.2f} seconds")

# Usage
with Timer():
    # Some time-consuming operation
    sum(range(1000000))

# Using contextlib for simple context managers
from contextlib import contextmanager

@contextmanager
def temporary_setting(setting_name, new_value):
    import os
    old_value = os.environ.get(setting_name)
    os.environ[setting_name] = new_value
    try:
        yield
    finally:
        if old_value is None:
            os.environ.pop(setting_name, None)
        else:
            os.environ[setting_name] = old_value

# Usage
with temporary_setting('DEBUG', 'True'):
    # Code that needs DEBUG=True
    pass
# DEBUG is automatically restored
```

## Bonus: Quick Checklist for Code Review üìã

When reviewing your Python code, ask yourself:

1. ‚úÖ **Mutable defaults?** Use `None` instead
2. ‚úÖ **Loop variables in lambdas?** Capture with default arguments
3. ‚úÖ **Modifying lists while iterating?** Use list comprehensions or iterate backwards
4. ‚úÖ **Comparing to `None`?** Use `is`, not `==`
5. ‚úÖ **Building lists in loops?** Consider list comprehensions
6. ‚úÖ **Need both index and value?** Use `enumerate()`
7. ‚úÖ **String concatenation in loops?** Use `join()`
8. ‚úÖ **Bare except clauses?** Be specific about exceptions
9. ‚úÖ **Opening files or connections?** Use context managers
10. ‚úÖ **Loop completed without breaking?** Consider the `else` clause

## The Magic Spell for Better Python Code ü™Ñ

Remember these incantations:

```python
# The Pythonic Way Spell
with open('file.txt') as f:
    data = [line.strip() for line in f if line.strip()]

# The Safe Exception Spell
try:
    result = risky_function()
except SpecificError as e:
    handle_error(e)

# The Efficient Loop Spell
for i, item in enumerate(items):
    if condition(item):
        break
else:
    handle_no_match()

# The Clean String Spell
message = ", ".join(f"{name}: {score}" for name, score in scores.items())
```

## Conclusion

These mistakes are incredibly common, and recognizing them is the first step to becoming a better Python developer. Don't worry if you've made all of these mistakes ‚Äì I certainly have! The key is to learn from them and gradually build better coding habits.

**Your Turn:** Which of these mistakes have you made? Share your own Python pitfalls in the comments below! 

**Next Steps:**
- Set up a linter like `pylint` or `flake8` to catch some of these automatically
- Use an IDE with good Python support (PyCharm, VS Code with Python extension)
- Practice code reviews with peers
- Write unit tests to catch these issues early

Remember, every expert was once a beginner who made these exact same mistakes. The magic is in the learning! üé©‚ú®

*Want more Python magic? Subscribe to our newsletter for weekly tips and tricks that will level up your coding skills!*